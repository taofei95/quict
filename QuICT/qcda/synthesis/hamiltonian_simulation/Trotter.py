from QuICT.algorithm.quantum_machine_learning.utils.hamiltonian import *
from QuICT.core import Circuit
from QuICT.core.gate import *
from QuICT.tools.exception.core import *
from QuICT.simulation.state_vector import StateVectorSimulator
from QuICT.qcda.synthesis.hamiltonian_simulation.unitary_matrix_encoding import prepare_G_state
import numpy as np


def trotter(hmtn, t, eps, init_statevec = None, iterations = None):
    '''
    This major function returns the trotter splitting circuit
    hmtn is input pauli string with coeff, gate and gate index
    eg. hmtn = [[1, 'X0', 'Z1', 'Y2'], [2, 'Z2']]
    t = evolution time
    eps = expected error
    indicate H = 1 * (X_0 pauli tensor Z_1 pauli tensor Y_2) + 2 * Z_2
    for every X gate, decompose as X = H Z H
    for every Y gate, decompose as Y = U_2 Z U_2
    circuit drawsn for pauli-Z tensors by CNOT and Rz gates, together with H and U_2 gates generated by X or Y gate

    example input:
    trotter([[1, 'X0', 'Y1'], [1, 'Z0', 'X1']], 1, 0.05, [0, 0, 0, 1])
    ie. H = 1 * (X_0 pauli tensor Y_1) + 1 * (Z_0 pauli tensor X_1)
    time = 1s
    error = 0.05
    initial state = [0, 0, 0, 1], which is |1>|1>

    '''

    h = Hamiltonian(hmtn)
    m = len(h._pauli_str)
    iterations = int((m ** 2) * (t ** 2) / eps)
    n = max(max(h._qubit_indexes)) + 1
    cgate = CompositeGate()
    cir = Circuit(n)
    gate_dict = {"X": X, "Y": Y, "Z": Z}

    for qbt_index, pauli_gate, ceoff in zip(h._qubit_indexes, h._pauli_gates, h._coefficients):
        for gateindex, gate in zip(qbt_index, pauli_gate):
            if gate_dict[gate] == X:
                H | cgate(gateindex)
            elif gate_dict[gate] == Y:
                U2(np.pi / 2, np.pi / 2) | cgate(gateindex)
            RZ = max(qbt_index)  # RZ = index of the central Rz
            CN = min(qbt_index)
        for i in range(CN, RZ):  # left CNOT gates
            CX | cgate([i, i + 1])
        Rz(2 * (t / iterations) * ceoff) | cgate(RZ)  # Rz
        for i in reversed(range(CN, RZ)):  # right CNOT gates
            CX | cgate([i, i + 1])
        for gateindex, gate in (zip(qbt_index, pauli_gate)):  # rgt gts
            if gate_dict[gate] == X:
                H | cgate(gateindex)
            elif gate_dict[gate] == Y:
                U2(np.pi / 2, np.pi / 2) | cgate(gateindex)
    cgate | cir
    return cir


def accfinalstate(hmtn, t, init_statevec = None):  # accurate final state 
    '''
    This can check the accurate final state vector by using matrix multiplication
    NB: this only applys to circuits with small number of qubits(n), due to matrix size is 2^n

    By using diagonalisation for H matrix
    H = UDU^-1, U is unitary matrix of eigenvectors, D is diagonal matrix of eigenvalues
    exp(-iHt) = exp(-i UDU^(-1) t) = U * exp(-iDt) * U^(-1) = U * exp(-i Dkk t) * U^(-1)

    '''    
    h = Hamiltonian(hmtn)
    n = max(max(h._qubit_indexes)) + 1
    matrix = Hamiltonian.get_hamiton_matrix(h, n)
    Eval, Evec = np.linalg.eig(matrix)
    U = Evec
    U_inverse = np.linalg.inv(Evec)
    D = np.diag(Eval)
    exp_D = np.zeros((2 ** n, 2 ** n), dtype='complex_')
    for i in range(2 ** n):
        a = t * complex(0, -1) * (D[i][i])
        exp_D[i][i] = np.exp(a)
    time_evolution_operator = np.matmul(np.matmul(U, exp_D), U_inverse)

    if init_statevec == None:
        ivec = np.zeros(n)
        ivec[0] = 1
        fvec = np.matmul(time_evolution_operator, ivec)
    else:
        fvec = np.matmul(time_evolution_operator, init_statevec)
        
    return fvec